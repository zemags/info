#### индексы в постгре
- аналогия оглавление в книге (смотрим главу и страницу откуда искать, быстрый поиск, при большом наборе данных)
- уменьшает алгоритмическую сложность и время поиска
- формируется из одного\нескольких (составной индекс) столбцов и указателей на строки таблицы

- пример:
    - индекс для поиска текста в верхнем регистре по колонке text_column
    - **create index** index_name on table_name(upper(text_column))

- по умолчанию индекс на основе **B-Tree**
  - можно индексировать любые данные которые могут быть отсортированы, т.е. для которых применимы операии равно, больше, меньше
  - покрывает множество кейсов большинства приложений
  - ускоряет сортировку при order by
  - индекс хранится в виде сбалансированного сильно ветвлящегося дерева
  - как правило хранение во внешней памяти

- можно указать другой:
	- **create index** index_name on table_name using gist (text_column)
		- **gist** - generalized search tree - сбалансированное дерево для данных любого типа (для котороых нет операций сравнения)
			- монжо юзать для геоданных или геометрических объектов и т.д.
			- можно сделать любой принцип разбиения например в **R-дерево** (с операторами "находится слева, справа, содержит")
		- **sp-gist** - space partitioning как gist, но несбалансирован
			- **kd-деревья** - разбиение множества на непересекающиеся объекты
			- слабоветвисты - сложно эффективно хранить во внешней памяти

- пример составного индекса:
	- **create index** index_name on table_name(column_1, column_2)
- пример поиска для column1:
	- select * from table_name where column_1 = "abc"
- НО для запроса по column_2 такой составной индекс уже не получится юзать

- индекс **GIN** - полнотекстовый поиск для массивов или jsonb