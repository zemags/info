#### о языке python¶
- интерпретируемый
    - интерпретатор читает код,
    - проверяет форматирование и синтаксис.
    - переводит исходные инструкции программы в байт-код
    - отправляется на виртуальную машину Python (PVM). Здесь выполняется байт-код на PVM
- динамическая типизация - сам определить тип
- сильная типизация - нельзя смешать разные типы в выражении, например нельзя складывать строки и числа

#### использование памяти в python¶
 - garbage collector считает ссылки
 - если количество ссылок на объект равно нулю, память очищается.

#### Что такое функция-замыкание?
- Функции могут быть вложенными, и они могут захватывать и уносить с собой часть состояния родительской функции.

#### Полиморфизм
- Полиморфизм - разное поведение одного и того же метода в разных классах.
- можно сложить два числа или сложить две строки. получим разный результат, так как числа и строки это разными классами.

#### Что такое глубокое копирование? (deepcopy)
- Глубокая копия - выполняет процесс копирования рекурсивно.
- Это означает конструирование сначала нового объекта коллекции, а затем рекурсивное его заполнение копиями дочерних объектов, найденных в оригинале.
- выполняется обход всего дерева объектов целиком, создается полностью независимый клон исходного объекта и его потомков.
- копия становится независимой.

#### обрабокта ошибок
- try - ожидает исключение
- except - обработки исключения
- else - если исключений не произошло
- finally - ВСЕГДА выполняется

#### Какой словарь поддерживает порядок ключей?
 - collections.OrderedDict
```python
import collections
d = collections.OrderedDict(one=1, two=2, three=3)
```

#### Что такое статитические методы?
- не может модифицировать состояние объекта или класса.
- ограничены теми данными, к которым они могут получить доступ.
```python
class MyClass:
    @staticmethod
    def staticmethod():
        return 'вызван статический метод'
```

#### Что является объектом в python?
- Строки, списки, модули, функции, классы

#### Что такое "функция высокого порядка"?
- Функции, которые в качестве аргументов могут принимать другие функции.
- являются непременным условием функционального стиля программирования.
- (higher-order functions) типа map(func, [1,2,3])

#### Что такое декоратор и для чего?
- блоки которые можно юзать для модификации поведения вызываемой функции без необратимого ее изменения.
- Многочисленные декораторы, размещенные над одной-единственной функцией, применяются снизу-вверх (стековая укладка декораторов).

#### Что такое мелкая копия? (shallow copy)
- Мелкая копия означает конструирование нового объекта-коллекции
- затем его заполнение ссылками на дочерние объекты, найденные в оригинале.
- имеет всего один уровень в глубину. нерекурсивная копия и поэтому не создает копий самих дочерних объектов.

#### отличие list (список) от set (множество) от tuple (кортеж)
- список изменяемый тип, хранит порядок, не хешируется как ключ для словаря не подойдет
- множество изменяемый тип, не хранит порядок, не хешируется как ключ для словаря не подойдет (альтернатива frozenset)
- кортеж неизменяемый тип, хранит порядок, хешируется

#### Чем полезны именованные кортежи? (namedtuple)
1. Кортежи неизменяемы.
2. Доступ к каждому хранящемуся в них объекту можно получить через уникальный (человекочитаемый) идентификатор.
```python
from collections import namedtuple
Car = namedtuple('Авто' , 'цвет пробег') #'цвет пробег' сплитует по пробелу на аргументы
Car = namedtuple('Авто', ['цвет', 'пробег']) #можно через список аргументы задать
mycar = Car('красный', 3812.4)
```

#### Как расширить именованный кортеж, производным подклассом?
- объекты namedtuple строятся поверх обычных классов Python, можно добавлять в них методы.
```python
Car = namedtuple('Авто', 'цвет пробег')
class MyCarWithMethods(Car):
    def hexcolor(self):
        if self.цвет == 'красный':
              return '#ff0000'
        else:
              return '#000000'
```

#### Как добавить новое неизменяемое поле в именованный кортеж? (immutable field)
- Самый легкий способ создать иерархии именованных кортежей — использовать свойства **_fields** базового кортежа:
```python
Car = namedtuple('Авто', 'цвет пробег')
ElectricCar = namedtuple('ЭлектрическоеАвто', Car._fields + ('заряд',))
```

#### Зачем нужен флаг преобразования "!r" ?
- В дандер методе __repr__ в воводимом значении типа:
```python
def __repr__(self):
    return 'self.color!r'
```

#### Какой тип словарь возвращает значение словаря по дефолту если ключа нет?
- collections.defaultdict
- Попытка доступа к отсутствующему ключу его создает и инициализирует, используя принятую по умолчанию фабрику, то есть в данном примере list().
```python
from collections import defaultdict
dd = defaultdict(list)
```

#### Для чего используется инструкция assert?
- assert - это средство отладки, помогает разрабам иденефицировать ошибки(неустронимые)
- могут быть глобально отключены в настройках интерпретатора. Не использовать для валидации данных.

#### Зачем нужны собственные классы исключения?
- ясная формулировка что делает код, облегчиает отладку.
- свои собственные исключения производные от Exception или например ValueError или KeyError .

#### Как производить поиск в многочисленных словарях как в одной таблице?
- collections.ChainMap
```python
from collections import ChainMap
dict1 = {'один': 1, 'два': 2}
dict2 = {'три': 3, 'четыре': 4}
chain = ChainMap(dict1, dict2)
```

#### Одинарный начальный символ подчеркивания: _var
- имя предназначено для внутреннего использования.
- Python не импортирует такие имена из модулей или файлов, если там нет метода __all__.

#### За чем следят абстрактные классы?
- чтобы производные классы реализовывали те или иные методы базового класса во время создания экземпляра.
- помогает избежать ошибок и сделать иерархии классов более легкими в сопровождении.
```python
from abc import ABCMeta, abstractmethod
class Base(metaclass=ABCMeta):
    @abstractmethod
    def foo(self):
         pass
    @abstractmethod
    def bar(self):
         pass
```

#### Что такое переменные экземпляра?
- всегда привязаны к конкретному экземпляру объекта.
- содержимое хранится в каждом отдельном объекте, созданном на основе класса.
```python
class Dog:
   num_legs = 4
   def __init__(self, name):
        self.name = name # <- Переменная экземпляра
jack = Dog('Джек')
print(jack.name)
```
- попытка получить доступ к переменной экземпляра через класс вызовет AttributeError.
```python
print(Dog.name)
AttributeError:
```

#### Что такое хешируемый объект?
- Хешируемый объект имеет хеш-значение, оно не меняется в течение его жизни (см. __hash__ )
- его можно сравнивать с другими объектами (см. __eq__ ).
- эквивалентные друг другу хешируемые объекты должны иметь одинаковое хеш-значение.

#### На что указывает двойной начальный и замыкающий символ подчеркивания __var__?
- специальные методы определенные языком Python - магические методы

#### Зачем нужен декоратор functools.wraps?
- чтобы переносить метаданные из недекорированного вызываемого объекта в декорированный

#### итератор
-  объект как правило класс, в нем методы iter (вернет self) и next (возвращает следующее значение)
-  если следующего значения нет то исключение StopIteration

#### функция-генератор
- в ней используется yield.
- инструкция yield приостанавливает функцию, при этом она возвращает какое-то значение.
- метод .close() — останавливает выполнение генератора;
- метод .throw() — генератор бросает исключение;
- метод .send() — интересный метод, позволяет отправлять значения генератору.

При первом вызове метода next() выполняется код функции с первой команды до yield. При втором next() и последующих до конца генератора — код со следующей после yield команды и до тех пор, пока yield не встретится снова.

#### Наследование
- дочерний класс содержит все атрибуты родительского класса
- некоторые могут быть переопределены или добавлены в дочернем.
- Например, мы можем создать свой класс, похожий на словарь:
```python
class Mydict(dict):
    def get(self, key, default = 0):
        return dict.get(self, key, default)

a = dict(a=1, b=2)
b = Mydict(a=1, b=2)
# Класс Mydict ведёт себя точно так же, как и словарь, за исключением того, что метод get по умолчанию возвращает не None, а 0.
b['c'] = 4
print(b) # {'a': 1, 'c': 4, 'b': 2}
print(a.get('v')) #None
print(b.get('v')) #0
```

#### Что такое лямба-функции?
- функции одного-единственного выражения, которые не обязательно привязаны к имени - анонимны

#### Что такое переменные класса?
- объявляются внутри определения класса вне методов экземпляра
- не привязаны к экземпляру класса.
- хранят свое содержимое в самом классе, и все объекты, созданные на основе класса, предоставляют общий доступ к одинаковому набору переменных класса. - - Например, это означает, что модификация переменной класса одновременно затрагивает все экземпляры объекта.
```python
class Dog:
    num_legs = 4 # <- Переменная класса
    def __init__(..
jack=Dog('Jack')
print(jack.num_legs) # 4
```

#### Что такое методы класса?
- Вместо параметра self методы класса принимают параметр cls, который указывает на класс.
```python
class MyClass:
    @classmethod
    def classmethod(cls):
         return 'вызван метод класса', cls
# @classmethod - декоратор указывает что это метод класса
```

#### Что дает ответом is и ==? (a is b, a==b)
- is дает True , если две переменные указывают на тот же самый (идентичный) объект.
- == дает True , если объекты, на которые ссылаются переменные, равны (имеют одинаковое содержимое).

#### Что делает метод _replace именованного кортежа?
- Создает (мелкую) копию кортежа и позволяет вам выборочно заменять некоторые его поля:
```python
my_car._replace(цвет='синий')
```

#### Для чего используется одинарный замыкающий символ подчеркивания var_?
- избежать конфликта с ключевыми словами Python

#### Что возвращает метод именованного кортежа _asdict?
- содержимое именованного кортежа в виде словаря:
```python
my_car._asdict()
OrderedDict([('цвет', 'красный'), ('пробег', 3812.4)])
```

#### Как используются менеджеры контекста with?
- упрощает обработку исключений(try/finally заменяет менеджер контекста)
- Для управления безопасным получением и высвобождением системных ресурсов
- пример: не допускать утечку дескриптора файла.
- можно через класс с методами __init__, __enter__, __exit__ либо через contextlib.contextmanager как декоратор

#### Что такое шаблонные строки?
 - С помощью модуля string.Template можно делать в виде:
```python
name=Bob
t = Template('Эй, $name!')
t.subtitute(name=name)
# 'Эй, Bob'
```

#### Для чего нужен метод __repr__?
- его результат должен быть однозначным.
- Если опустить метод __str__ , то Python в поисках __str__ отыграет назад к результату __repr__.

#### Что делает двойной начальный символ подчеркивания __var (name mangling)?
- механизм искажения имен при использовании в контексте класса
- чтоб избежать конфликта в будущем если класс будет расширен(подкласс)

#### Как создать словарь только для чтения?
- types.MappingProxyType
```python
from types import MappingProxyType
writable = {'один': 1, 'два': 2} # доступный для обновления
read_only = MappingProxyType(writable)
```

#### Для чего нужен метод __unicode__ в python 2?
- В py2 другая модель строковых данных. Для представления текста два типа:
- str-ограничен набором символов ASCII;
- unicode-равен типу str в py3.
- Поэтому в py2 __unicode__, которые возвращает символы, а __str__ возвращает байты.

#### Что возвращает метод именованного кортежа _asdict?
- содержимое именованного кортежа в виде словаря:
```python
my_car._asdict()
OrderedDict([('цвет', 'красный'), ('пробег', 3812.4)])
```

#### Инкапсуляция
- ограничение доступа к методам и переменным объекта.
- делает некоторые из компонент доступными только внутри класса.
- Одиночное подчеркивание перед переменной или методом говорит что, они не предназначены для использования вне методов класса,
- однако атрибут доступен по этому имени.
```python
class A:
    def _private(self):
        print("Это приватный метод!")
a = A()
a._private() # Это приватный метод!
```
- Двойное подчеркивание в начале имени атрибута даёт большую защиту: атрибут становится недоступным по этому имени.
```python
class B:
    def __private(self):
        print("Это приватный метод!")

b = B()
b.__private()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'B' object has no attribute '__private'
```
- полностью это не защищает, так как атрибут доступен под именем _ИмяКласса__ИмяАтрибута:
```python
b._B__private() # Это приватный метод!
```

#### Что такое методы экземпляра?
- Через self методы экземпляра могут получать доступ к атрибутам и методам в объекте.
- могут модифицировать состояние объекта,
- могут получать доступ к самому классу через атрибут self.__class__ .
- могут модифицировать состояние класса.
```python
class MyClass:
     def method(self):
          return 'вызван метод экземпляра', self
```

#### Зачем нужен метод __str__?
- Для преобразования объекта в строковое значение посредство(print(), str(), .format()).
- Результат метода __str__ должен быть удобочитаемым.

#### Конструкторы
- вызываются при создании объекта класса

#### деструкторы
- деструкторы вызываются, когда объект класса уничтожается.
- Ненужные объекты удаляются автоматически.
- освобождает пространство памяти, которое называется сборкой мусора.
- запускается автоматически.

#### [дискриптор](https://webdevblog.ru/chto-takoe-deskriptory-i-ih-ispolzovanie-v-python-3-6/)
- используются только если создаете ORM или новый фреймворк.
- это атрибут объекта со “связанным поведением”, при доступе к которому его поведение переопределяется методом протокола дескриптора.
- Эти методы  __get__, __set__ и __delete__.
- Если хотя бы один из этих методов определен в объекте, то можно сказать что этот метод дескриптор.