# Clean Architecture + Domain-Driven Design (DDD)

> **Цель** — построить систему, где бизнес-логика лежит в центре, остаётся независимой от внешних деталей (UI, БД, фреймворки) и легко развивается по мере изменения требований.

---

## 1. Что такое Clean Architecture

| Слой архитектуры	|Компоненты слоя	|Допустимые зависимости	|Роль / ответственность                      |
|-----------------------|---------------------------------|----------------------|----------------------------------------------|
| **Entities**          | Бизнес-объекты, инварианты      | ✗                    | Глубокая предметная модель                   |
| **Use Cases**         | Сценарии, правила приложения    | ➡ Entities          | Координирует работу сущностей                |
| **Interface Adapters**| Controllers, Presenters, DTO    | ➡ Use Cases         | Преобразует данные для/из внешнего мира      |
| **Frameworks & Drivers**| UI, БД, MQ, 3rd-party SDK    | ➡ Adapters          | Инфраструктура, которую можно заменить       |

*__Dependency Rule__: код всегда зависит только **внутрь**; наружные слои не видят деталей внутренних.*

### Ключевые преимущества

* **Тестируемость** — ядро можно юнит-тестировать без веб-сервера или БД.  
* **Масштабируемость** — добавляйте новые UI, мигрируйте с REST на gRPC без переписывания бизнес-логики.  
* **Заменяемость технологий** — смена СУБД или фреймворка UI затрагивает лишь внешний слой.  
* **Понижающая связность** — каждый слой решает строго свою задачу.

---

## 2. Domain-Driven Design (DDD)

DDD — набор стратегий и тактик для моделирования сложных предметных областей на основе **единых терминов (Ubiquitous Language)**.

### Тактические паттерны

| Паттерн           | Роль в модели                                                                             |
|-------------------|-------------------------------------------------------------------------------------------|
| **Entity**        | Объект с идентичностью и жизненным циклом                                                 |
| **Value Object**  | Неизменяемый объект-значение (дата, деньги)                                               |
| **Aggregate Root**| Гарант целостности внутри совокупности сущностей                                          |
| **Repository**    | Абстракция хранения Aggregates, скрывающая БД                                             |
| **Domain Service**| Операции, неуместные внутри одной Entity (например, расчёт курса валют)                   |
| **Domain Event**  | Явное сообщение о факте в домене («Заказ оплачен»)                                        |

### Стратегические паттерны

* **Bounded Context** — изолированная модель предметной области с собственным языком.  
* **Context Map** — схема взаимодействия контекстов (Shared Kernel, ACL, Published Language и т.д.).  

---

## 3. Как сочетать Clean Architecture и DDD

| Clean Layer          | DDD-содержимое                                    |
|----------------------|---------------------------------------------------|
| **Entities**         | Entities, Value Objects, Domain Events            |
| **Use Cases**        | Application Services (координируют агрегаты)      |
| **Interface Adapters**| DTO ↔ Aggregates, Repositories ↔ БД             |
| **Frameworks & Drivers**| REST controllers, ORM, Message Queue adapters |

Таким образом, Clean Architecture даёт **технический каркас** слоёв, а DDD — **семантическое содержание** этих слоёв.

---

## 4. Мини-чек-лист внедрения

1. **Определите Bounded Contexts** и их границы.  
2. Сформируйте **Ubiquitous Language** вместе с доменными экспертами.  
3. Смоделируйте **Aggregates** ⇒ Entities/Value Objects.  
4. Постройте слой **Use Cases** как сценарии, вызываемые UI или внешними системами.  
5. Реализуйте **Repositories** в адаптере, скрывая детали БД.  
6. Пишите **тесты ядра** (Entities + Use Cases) без подключения инфраструктуры.  
7. Добавляйте/заменяйте фреймворки, не трогая доменную модель.  

---

## 5. Частые ошибки и советы

| Ошибка                                   | Как избежать                                                         |
|------------------------------------------|-----------------------------------------------------------------------|
| «Толстые» контроллеры / сервисы          | Перенесите бизнес-правила в Use Cases и Entities.                     |
| Утечка ORM-сущностей в доменный слой     | Используйте мапперы (DTO ↔ VO/Entity).                               |
| Отсутствие Ubiquitous Language в коде    | Именуйте классы и методы терминологией домена, а не инфраструктуры.   |
| Монолит «God Aggregate»                  | Делите по **Transactional Consistency Boundary**.                     |

---

## 6. Результат

* **Код отражает бизнес** — изменения требований → локальные изменения в Entities / Use Cases.  
* **Система эволюционирует** — легко тестируется, масштабируется, позволяет выбирать оптимальное железо или облака.  
* **Низкие риски миграций** — новая БД или фреймворк UI подключается в самом внешнем слое, не ломая ядро.
